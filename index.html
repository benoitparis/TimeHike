

<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
      html { height: 100% }
      body { height: 100%; margin: 0; padding: 0 }
    </style>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
	<script src="js/MercatorProjection.js"></script>
	<script src="js/Three.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/Stats.js"></script>
	<script src="js/THREEx.KeyboardState.js"></script>
	<script src="js/THREEx.FullScreen.js"></script>
	<script src="js/THREEx.WindowResize.js"></script>
    <script type="text/javascript" src="http://maps.googleapis.com/maps/api/js?key=AIzaSyB3uE-6c9hDWiNbK4VGRctWI1RbNcInGxY&sensor=false">
    </script>

  </head>
  <body onload="initialize()">
    <div id="map_canvas" style="width:256px; height:256px; position:absolute;top:0px;right:0px;"></div>
    <canvas id="tt_canvas" width="512" height="512" style="display:none;"></div>
    <div id="background" style="position:absolute;top:0px;left:0px;z-index: -1;"></div>
	    <script type="text/javascript">
	
var G = google.maps;
var proj = new MercatorProjection();
var directionsService = new google.maps.DirectionsService();
var TILE_SIZE = 256;
var timeTravelWPs = new Array();
var currentZoom = 13;
var currentScale = Math.pow(2,currentZoom);
var currentCenterLatLng = new google.maps.LatLng(48.860099,2.333347);
var currentCenterPoint, currentCenterPix;
var updateCenterPoint = function(){
	currentCenterPoint = proj.fromLatLngToPoint(currentCenterLatLng);
	currentCenterPix = { x: Math.floor(currentCenterPoint.x * currentScale), y: Math.floor(currentCenterPoint.y * currentScale)}
}
updateCenterPoint();
var bounds, sw, ne;


var currentMesh;
var currentWireMesh;

// create a canvas element
var canvas2 = $("#tt_canvas")[0];
var context2 = canvas2.getContext('2d');
// canvas contents will be used for a texture
var texture2 = new THREE.Texture(canvas2);
texture2.needsUpdate = true;

var scene = new THREE.Scene();





////////////////////////////////////////////  ---------------   DELAUNAY     BEGIN

      function Triangle(a, b, c) {
        this.a = a
        this.b = b
        this.c = c

        var A = b.x - a.x,
            B = b.y - a.y,
            C = c.x - a.x,
            D = c.y - a.y,
            E = A * (a.x + b.x) + B * (a.y + b.y),
            F = C * (a.x + c.x) + D * (a.y + c.y),
            G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)),
            minx, miny, dx, dy
  
        /* If the points of the triangle are collinear, then just find the
         * extremes and use the midpoint as the center of the circumcircle. */
        if(Math.abs(G) < 0.000001) {
          minx = Math.min(a.x, b.x, c.x)
          miny = Math.min(a.y, b.y, c.y)
          dx   = (Math.max(a.x, b.x, c.x) - minx) * 0.5
          dy   = (Math.max(a.y, b.y, c.y) - miny) * 0.5

          this.x = minx + dx
          this.y = miny + dy
          this.r = dx * dx + dy * dy
        }

        else {
          this.x = (D*E - B*F) / G
          this.y = (A*F - C*E) / G
          dx = this.x - a.x
          dy = this.y - a.y
          this.r = dx * dx + dy * dy
        }
      }


      function byX(a, b) {
        return b.x - a.x
      }

      function dedup(edges) {
        var j = edges.length,
            a, b, i, m, n

        outer: while(j) {
          b = edges[--j]
          a = edges[--j]
          i = j
          while(i) {
            n = edges[--i]
            m = edges[--i]
            if((a === m && b === n) || (a === n && b === m)) {
              edges.splice(j, 2)
              edges.splice(i, 2)
              j -= 2
              continue outer
            }
          }
        }
      }

      function triangulate(vertices) {
        /* Bail if there aren't enough vertices to form any triangles. */
        if(vertices.length < 3)
          return []

        /* Ensure the vertex array is in order of descending X coordinate
         * (which is needed to ensure a subquadratic runtime), and then find
         * the bounding box around the points. */
        vertices.sort(byX)

        var i    = vertices.length - 1,
            xmin = vertices[i].x,
            xmax = vertices[0].x,
            ymin = vertices[i].y,
            ymax = ymin

        while(i--) {
          if(vertices[i].y < ymin) ymin = vertices[i].y
          if(vertices[i].y > ymax) ymax = vertices[i].y
        }

        /* Find a supertriangle, which is a triangle that surrounds all the
         * vertices. This is used like something of a sentinel value to remove
         * cases in the main algorithm, and is removed before we return any
         * results.
         * 
         * Once found, put it in the "open" list. (The "open" list is for
         * triangles who may still need to be considered; the "closed" list is
         * for triangles which do not.) */
        var dx     = xmax - xmin,
            dy     = ymax - ymin,
            dmax   = (dx > dy) ? dx : dy,
            xmid   = (xmax + xmin) * 0.5,
            ymid   = (ymax + ymin) * 0.5,
            open   = [
              new Triangle(
                {x: xmid - 20 * dmax, y: ymid -      dmax, __sentinel: true},
                {x: xmid            , y: ymid + 20 * dmax, __sentinel: true},
                {x: xmid + 20 * dmax, y: ymid -      dmax, __sentinel: true}
              )
            ],
            closed = [],
            edges = [],
            j, a, b

        /* Incrementally add each vertex to the mesh. */
        i = vertices.length
        while(i--) {
          /* For each open triangle, check to see if the current point is
           * inside it's circumcircle. If it is, remove the triangle and add
           * it's edges to an edge list. */
          edges.length = 0
          j = open.length
          while(j--) {
            /* If this point is to the right of this triangle's circumcircle,
             * then this triangle should never get checked again. Remove it
             * from the open list, add it to the closed list, and skip. */
            dx = vertices[i].x - open[j].x
            if(dx > 0 && dx * dx > open[j].r) {
              closed.push(open[j])
              open.splice(j, 1)
              continue
            }

            /* If not, skip this triangle. */
            dy = vertices[i].y - open[j].y
            if(dx * dx + dy * dy > open[j].r)
              continue

            /* Remove the triangle and add it's edges to the edge list. */
            edges.push(
              open[j].a, open[j].b,
              open[j].b, open[j].c,
              open[j].c, open[j].a
            )
            open.splice(j, 1)
          }

          /* Remove any doubled edges. */
          dedup(edges)

          /* Add a new triangle for each edge. */
          j = edges.length
          while(j) {
            b = edges[--j]
            a = edges[--j]
            open.push(new Triangle(a, b, vertices[i]))
          }
        }

        /* Copy any remaining open triangles to the closed list, and then
         * remove any triangles that share a vertex with the supertriangle. */
        Array.prototype.push.apply(closed, open)

        i = closed.length
        while(i--)
          if(closed[i].a.__sentinel ||
             closed[i].b.__sentinel ||
             closed[i].c.__sentinel)
            closed.splice(i, 1)

        /* Yay, we're done! */
        return closed
      }


////////////////////////////////////////////  ---------------   DELAUNAY     END





/* 	Three.js  */

// MAIN
if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
// custom global variables
var cube;



function getDelaunayGeometry(){

	var geometry = new THREE.Geometry();
	var  i=0,
	  vertices = new Array()

	while(i<timeTravelWPs.length) {
	  x = timeTravelWPs[i].px.x - currentCenterPix.x;
	  y = timeTravelWPs[i].px.y - currentCenterPix.y;
	  z = -timeTravelWPs[i].z / 30


	vertices[i] = {x: x, y: y, z:z, vi:i};
	geometry.vertices.push( new THREE.Vector3( x, y, z ) );
	i++;

	}

	console.time("triangulate")
	var triangles = triangulate(vertices)
	console.timeEnd("triangulate")

	i = triangles.length


	for ( idx = 0; idx < triangles.length ; idx ++) {

		var face = new THREE.Face3( 
			triangles[idx].a.vi,
			triangles[idx].b.vi,
			triangles[idx].c.vi );

		geometry.faces.push( face );
		geometry.faceVertexUvs[ 0 ].push( [
			new THREE.UV( triangles[idx].a.x/512 +0.5, -triangles[idx].a.y/512 +0.5),
			new THREE.UV( triangles[idx].b.x/512 +0.5, -triangles[idx].b.y/512 +0.5),
			new THREE.UV( triangles[idx].c.x/512 +0.5, -triangles[idx].c.y/512 +0.5)
		] );

	}
	return geometry;

}


function updateTimeMap() {
	console.log("updateTimeMap");
	scene.remove( currentMesh );
	scene.remove( currentWireMesh );
	
	
	  
	var material2 = new THREE.MeshBasicMaterial( {map: texture2} );		
	
	var geometry = getDelaunayGeometry();
	
	var mesh2 = new THREE.Mesh(
		geometry,
		material2
	  );
	mesh2.position.set(0,-10,0);
	mesh2.rotation.x = Math.PI / 2;
	currentMesh = mesh2;
	scene.add( mesh2 );
	
	
	var material3 = new THREE.MeshNormalMaterial( {wireframe: true, color:"#ff00ff"} );		
	var mesh3 = new THREE.Mesh(
		geometry,
		material3
	  );
	mesh3.position.set(0,-5,0);
	mesh3.rotation.x = Math.PI / 2;
	currentWireMesh = mesh3;
	scene.add( mesh3 );
}

// FUNCTIONS 		
function init() 
{
	// SCENE
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 32, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.01, FAR = 200000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.set(0,700,450);
	camera.lookAt(scene.position);	
	// RENDERER
	renderer = new THREE.WebGLRenderer( {antialias:true} );
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT-25);
	container = $("#background")[0];
	document.body.appendChild( container );
	container.appendChild( renderer.domElement );
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	// CONTROLS
	controls = new THREE.OrbitControls( camera );
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );


	
	////////////
	// CUSTOM //
	////////////
	

	

		
		var axes = new THREE.AxisHelper();
		axes.scale.set( 1, 1, 1 );
		scene.add( axes );
	
		animate();

}
init();

function drawToCanvas(src, posX, posY){
	// load an image
		var imageObj = new Image();
		imageObj.crossOrigin = "anonymous";
		imageObj.src = src;
		// after the image is loaded, this function executes
		imageObj.onload = function()
		{  
			context2.drawImage(imageObj, posX, posY);
			if ( texture2 ) // checks if texture exists
				texture2.needsUpdate = true;
		};  

}

function animate() 
{
    requestAnimationFrame( animate );
	render();		
	update();
}

function update()
{
	if ( keyboard.pressed("z") ) 
	{ 
		// do something
	}
	
	controls.update();
	stats.update();
}

function render() 
{
	renderer.render( scene, camera );
}


var pushDirection = function (start,end){
	var request = {
		origin:start,
		destination:end,
		travelMode: google.maps.DirectionsTravelMode.WALKING
	};
	directionsService.route(request, function(response, status) {
	  if (status == google.maps.DirectionsStatus.OK) {
		console.log(response);
		var steps = response.routes[0].legs[0].steps;
		currentDuration = 0;
		for ( idx = 0; idx < steps.length ; idx ++) {
			var path = steps[idx].path
			for ( idx2 = 0; idx2 < path.length ; idx2 ++) {
				(function(){
					var endLatLng = path[idx2];
					var endPt = proj.fromLatLngToPoint(endLatLng);
					var endPix = { x: Math.floor(endPt.x * currentScale), y: Math.floor(endPt.y * currentScale)};
					timeTravelWPs.push({ 
						latLng:endLatLng,
						// YUCK YUCK YUCK
						z:currentDuration + idx2 * steps[idx].duration.value/path.length,
						pt:endPt,
						px:endPix});
				})();
			}
			currentDuration += steps[idx].duration.value;
		}
		console.log(timeTravelWPs);
		updateTimeMap();
		
	  }
	});


}

var pushGrid = function(num){
	var a=0,b=0;
	while (a<=num) {
		console.log(a);
		while (b<=num) {
			(function(){
				var lat = (sw.lat()+((a-1)*2.05+1)/num*(ne.lat()-sw.lat()));
				var lng = (sw.lng()+((b-1)*2.05+1)/num*(ne.lng()-sw.lng()));			
				console.log("test "+a+" "+b+" "+lat+" "+lng);
				pushDirection(
					currentCenterLatLng.toString(),
					""+lat+","+lng);
			})();
			b++;
		}
		b=0;
		a++;
	}
}


function initialize() {

	var mapOptions = {
		center: currentCenterLatLng,
		zoom: 13,
		mapTypeId: google.maps.MapTypeId.ROADMAP
	};
	map = new google.maps.Map(document.getElementById("map_canvas"),
	mapOptions);
	
	google.maps.event.addListener(map, 'idle', function() {
		bounds = map.getBounds();
		sw = bounds.getSouthWest();
		ne = bounds.getNorthEast();
		currentCenterLatLng = map.getCenter();
		updateCenterPoint();
		currentZoom = map.getZoom();
		
		
		currentScale = Math.pow(2,currentZoom);
		timeTravelWPs = new Array();
		pushGrid(2);
		
		var lowX = Math.floor(currentCenterPix.x -(512/2));
		var highX = Math.floor(currentCenterPix.x +(512/2));
		var lowY = Math.floor(currentCenterPix.y -(512/2));
		var highY = Math.floor(currentCenterPix.y +(512/2));
		
		var lowTileX = Math.floor(lowX / TILE_SIZE);
		var highTileX = Math.floor(highX / TILE_SIZE) +1;
		var lowTileY = Math.floor(lowY / TILE_SIZE);
		var highTileY = Math.floor(highY / TILE_SIZE) +1;
		
		
		for ( tileX = lowTileX; tileX < highTileX ; tileX ++){
			for ( tileY = lowTileY; tileY < highTileY ; tileY ++){
				(function(){
					var cornerX = tileX * TILE_SIZE;
					var cornerY = tileY * TILE_SIZE;
					var img = document.createElement('img');
					img.src = "http://mt1.googleapis.com/vt"
						+ "?x=" + tileX
						+ "&y=" + tileY
						+ "&z=" + currentZoom;
					drawToCanvas(img.src, cornerX-lowX,cornerY-lowY);
				})();
			}
		}
	});
	
	google.maps.event.addListener(map, 'mousedown', function(event) {
		console.log(event);
	});
	
}




    </script>
  </body>
</html>