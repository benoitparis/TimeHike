

<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
      html { height: 100% }
      body { height: 100%; margin: 0; padding: 0 }
    </style>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
	<script src="js/MercatorProjection.js"></script>
	<script src="js/Three.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/Stats.js"></script>
	<script src="js/THREEx.KeyboardState.js"></script>
	<script src="js/THREEx.FullScreen.js"></script>
	<script src="js/THREEx.WindowResize.js"></script>
    <script type="text/javascript" src="http://maps.googleapis.com/maps/api/js?key=AIzaSyB3uE-6c9hDWiNbK4VGRctWI1RbNcInGxY&sensor=false">
    </script>

  </head>
  <body onload="initialize()">
    <div id="map_canvas" style="width:256px; height:256px; position:absolute;top:0px;right:0px;"></div>
    <canvas id="tt_canvas" width="512" height="512" style="display:none;"></div>
    <div id="background" style="position:absolute;top:0px;left:0px;z-index: -1;"></div>
	    <script type="text/javascript">
	
var G = google.maps;
var proj = new MercatorProjection();
var TILE_SIZE = 256;

// create a canvas element
var canvas2 = $("#tt_canvas")[0];
var context2 = canvas2.getContext('2d');
// canvas contents will be used for a texture
var texture2 = new THREE.Texture(canvas2);
texture2.needsUpdate = true;

/* 	Three.js  */

// MAIN
if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
// custom global variables
var cube;

init();
animate();

// FUNCTIONS 		
function init() 
{
	// SCENE
	scene = new THREE.Scene();
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 32, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.01, FAR = 200000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.set(0,700,450);
	camera.lookAt(scene.position);	
	// RENDERER
	renderer = new THREE.WebGLRenderer( {antialias:true} );
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT-25);
	container = $("#background")[0];
	document.body.appendChild( container );
	container.appendChild( renderer.domElement );
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	// CONTROLS
	controls = new THREE.OrbitControls( camera );
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );


	
	////////////
	// CUSTOM //
	////////////
	

	
	/////// draw image on canvas /////////
		  
		var material2 = new THREE.MeshBasicMaterial( {map: texture2} );
		material2.transparent = true;

		var mesh2 = new THREE.Mesh(
			new THREE.PlaneGeometry(canvas2.width, canvas2.height),
			material2
		  );
		mesh2.position.set(0,-10,0);
		mesh2.rotation.x = - Math.PI / 2;
		mesh2.doubleSided = true;
		scene.add( mesh2 );
		
		var axes = new THREE.AxisHelper();
		axes.scale.set( 1, 1, 1 );
		scene.add( axes );

	

}

function drawToCanvas(src, posX, posY){
	// load an image
		var imageObj = new Image();
		imageObj.crossOrigin = "anonymous";
		imageObj.src = src;
		// after the image is loaded, this function executes
		imageObj.onload = function()
		{  
			context2.drawImage(imageObj, posX, posY);
			if ( texture2 ) // checks if texture exists
				texture2.needsUpdate = true;
		};  

}

function animate() 
{
    requestAnimationFrame( animate );
	render();		
	update();
}

function update()
{
	if ( keyboard.pressed("z") ) 
	{ 
		// do something
	}
	
	controls.update();
	stats.update();
}

function render() 
{
	renderer.render( scene, camera );
}



function initialize() {

	var mapOptions = {
		center: new google.maps.LatLng(48.86144,2.333981),
		zoom: 13,
		mapTypeId: google.maps.MapTypeId.ROADMAP
	};
	map = new google.maps.Map(document.getElementById("map_canvas"),
	mapOptions);
	
	google.maps.event.addListener(map, 'idle', function() {
		var bounds = map.getBounds();
		var sw = bounds.getSouthWest();
		var ne = bounds.getNorthEast();
		var center = map.getCenter();
		var zoom = map.getZoom();
		$("#coords").text("lat: "+sw.lat()+" to "+ne.lat());
		//$("#tt_canvas").attr("src","http://maps.googleapis.com/maps/api/staticmap?center="+center+"&zoom="+zoom+"&size=512x512&sensor=false&scale=2");
		
		
		var scale = Math.pow(2,zoom);
		var centerPt = proj.fromLatLngToPoint(center);
		
		var lowX = Math.floor(centerPt.x * scale -(512/2));
		var highX = Math.floor(centerPt.x * scale +(512/2));
		var lowY = Math.floor(centerPt.y * scale -(512/2));
		var highY = Math.floor(centerPt.y * scale +(512/2));
		
		var lowTileX = Math.floor(lowX / TILE_SIZE);
		var highTileX = Math.floor(highX / TILE_SIZE) +1;
		var lowTileY = Math.floor(lowY / TILE_SIZE);
		var highTileY = Math.floor(highY / TILE_SIZE) +1;
		

		console.log("lowX"+lowX);
		console.log("highX"+highX);
		console.log("lowTileX"+lowTileX);
		console.log("highTileX"+highTileX);
		
		for ( tileX = lowTileX; tileX < highTileX ; tileX ++){
			for ( tileY = lowTileY; tileY < highTileY ; tileY ++){
				(function(){
					var cornerX = tileX * TILE_SIZE;
					var cornerY = tileY * TILE_SIZE;
					var img = document.createElement('img');
					img.src = "http://mt1.googleapis.com/vt"
						+ "?x=" + tileX
						+ "&y=" + tileY
						+ "&z=" + zoom;
					drawToCanvas(img.src, cornerX-lowX,cornerY-lowY);
				})();
			}
		}
	});
	
	google.maps.event.addListener(map, 'mousedown', function(event) {
		console.log(event);
	});
	
}




    </script>
  </body>
</html>