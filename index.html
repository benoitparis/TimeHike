

<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
      html { height: 100% }
      body { height: 100%; margin: 0; padding: 0 }
    </style>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
	<script src="js/MercatorProjection.js"></script>
	<script src="js/Three.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/Stats.js"></script>
	<script src="js/THREEx.KeyboardState.js"></script>
	<script src="js/THREEx.FullScreen.js"></script>
	<script src="js/THREEx.WindowResize.js"></script>
    <script type="text/javascript" src="http://maps.googleapis.com/maps/api/js?key=AIzaSyB3uE-6c9hDWiNbK4VGRctWI1RbNcInGxY&sensor=false">
    </script>

  </head>
  <body onload="initialize()">
    <div id="map_canvas" style="width:256px; height:256px; position:absolute;top:0px;right:0px;"></div>
    <canvas id="tt_canvas" width="512" height="512" style="display:none;"></div>
    <div id="background" style="position:absolute;top:0px;left:0px;z-index: -1;"></div>
	    <script type="text/javascript">
	
var G = google.maps;
var proj = new MercatorProjection();
var TILE_SIZE = 256;

// create a canvas element
var canvas2 = $("#tt_canvas")[0];
var context2 = canvas2.getContext('2d');
// canvas contents will be used for a texture
var texture2 = new THREE.Texture(canvas2);
texture2.needsUpdate = true;





////////////////////////////////////////////  ---------------   DELAUNAY     BEGIN

      function Triangle(a, b, c) {
        this.a = a
        this.b = b
        this.c = c

        var A = b.x - a.x,
            B = b.y - a.y,
            C = c.x - a.x,
            D = c.y - a.y,
            E = A * (a.x + b.x) + B * (a.y + b.y),
            F = C * (a.x + c.x) + D * (a.y + c.y),
            G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)),
            minx, miny, dx, dy
  
        /* If the points of the triangle are collinear, then just find the
         * extremes and use the midpoint as the center of the circumcircle. */
        if(Math.abs(G) < 0.000001) {
          minx = Math.min(a.x, b.x, c.x)
          miny = Math.min(a.y, b.y, c.y)
          dx   = (Math.max(a.x, b.x, c.x) - minx) * 0.5
          dy   = (Math.max(a.y, b.y, c.y) - miny) * 0.5

          this.x = minx + dx
          this.y = miny + dy
          this.r = dx * dx + dy * dy
        }

        else {
          this.x = (D*E - B*F) / G
          this.y = (A*F - C*E) / G
          dx = this.x - a.x
          dy = this.y - a.y
          this.r = dx * dx + dy * dy
        }
      }

      Triangle.prototype.draw = function(ctx) {
		console.log("TODO Triangle.prototype.draw");
        /*
		ctx.beginPath()
        ctx.moveTo(this.a.x, this.a.y)
        ctx.lineTo(this.b.x, this.b.y)
        ctx.lineTo(this.c.x, this.c.y)
        ctx.closePath()
        ctx.stroke()
		*/
      }

      function byX(a, b) {
        return b.x - a.x
      }

      function dedup(edges) {
        var j = edges.length,
            a, b, i, m, n

        outer: while(j) {
          b = edges[--j]
          a = edges[--j]
          i = j
          while(i) {
            n = edges[--i]
            m = edges[--i]
            if((a === m && b === n) || (a === n && b === m)) {
              edges.splice(j, 2)
              edges.splice(i, 2)
              j -= 2
              continue outer
            }
          }
        }
      }

      function triangulate(vertices) {
        /* Bail if there aren't enough vertices to form any triangles. */
        if(vertices.length < 3)
          return []

        /* Ensure the vertex array is in order of descending X coordinate
         * (which is needed to ensure a subquadratic runtime), and then find
         * the bounding box around the points. */
        vertices.sort(byX)

        var i    = vertices.length - 1,
            xmin = vertices[i].x,
            xmax = vertices[0].x,
            ymin = vertices[i].y,
            ymax = ymin

        while(i--) {
          if(vertices[i].y < ymin) ymin = vertices[i].y
          if(vertices[i].y > ymax) ymax = vertices[i].y
        }

        /* Find a supertriangle, which is a triangle that surrounds all the
         * vertices. This is used like something of a sentinel value to remove
         * cases in the main algorithm, and is removed before we return any
         * results.
         * 
         * Once found, put it in the "open" list. (The "open" list is for
         * triangles who may still need to be considered; the "closed" list is
         * for triangles which do not.) */
        var dx     = xmax - xmin,
            dy     = ymax - ymin,
            dmax   = (dx > dy) ? dx : dy,
            xmid   = (xmax + xmin) * 0.5,
            ymid   = (ymax + ymin) * 0.5,
            open   = [
              new Triangle(
                {x: xmid - 20 * dmax, y: ymid -      dmax, __sentinel: true},
                {x: xmid            , y: ymid + 20 * dmax, __sentinel: true},
                {x: xmid + 20 * dmax, y: ymid -      dmax, __sentinel: true}
              )
            ],
            closed = [],
            edges = [],
            j, a, b

        /* Incrementally add each vertex to the mesh. */
        i = vertices.length
        while(i--) {
          /* For each open triangle, check to see if the current point is
           * inside it's circumcircle. If it is, remove the triangle and add
           * it's edges to an edge list. */
          edges.length = 0
          j = open.length
          while(j--) {
            /* If this point is to the right of this triangle's circumcircle,
             * then this triangle should never get checked again. Remove it
             * from the open list, add it to the closed list, and skip. */
            dx = vertices[i].x - open[j].x
            if(dx > 0 && dx * dx > open[j].r) {
              closed.push(open[j])
              open.splice(j, 1)
              continue
            }

            /* If not, skip this triangle. */
            dy = vertices[i].y - open[j].y
            if(dx * dx + dy * dy > open[j].r)
              continue

            /* Remove the triangle and add it's edges to the edge list. */
            edges.push(
              open[j].a, open[j].b,
              open[j].b, open[j].c,
              open[j].c, open[j].a
            )
            open.splice(j, 1)
          }

          /* Remove any doubled edges. */
          dedup(edges)

          /* Add a new triangle for each edge. */
          j = edges.length
          while(j) {
            b = edges[--j]
            a = edges[--j]
            open.push(new Triangle(a, b, vertices[i]))
          }
        }

        /* Copy any remaining open triangles to the closed list, and then
         * remove any triangles that share a vertex with the supertriangle. */
        Array.prototype.push.apply(closed, open)

        i = closed.length
        while(i--)
          if(closed[i].a.__sentinel ||
             closed[i].b.__sentinel ||
             closed[i].c.__sentinel)
            closed.splice(i, 1)

        /* Yay, we're done! */
        return closed
      }
/*
       canvas = document.getElementById("canvas"),
          ctx = canvas.getContext("2d")
		  */






////////////////////////////////////////////  ---------------   DELAUNAY     END








/* 	Three.js  */

// MAIN
if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
// custom global variables
var cube;

init();
animate();

// FUNCTIONS 		
function init() 
{
	// SCENE
	scene = new THREE.Scene();
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 32, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.01, FAR = 200000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.set(0,700,450);
	camera.lookAt(scene.position);	
	// RENDERER
	renderer = new THREE.WebGLRenderer( {antialias:true} );
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT-25);
	container = $("#background")[0];
	document.body.appendChild( container );
	container.appendChild( renderer.domElement );
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	// CONTROLS
	controls = new THREE.OrbitControls( camera );
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );


	
	////////////
	// CUSTOM //
	////////////
	

	
	/////// draw image on canvas /////////
		  
		var material2 = new THREE.MeshBasicMaterial( {map: texture2} );
		//var material2 = new THREE.MeshNormalMaterial( {map: texture2} );		
		
		
///////////////////----------------------------
		var geometry = new THREE.Geometry();
		var width=canvas2.width,
			height=canvas2.height, 
			segmentsWidth=16, 
			segmentsheight=16;
		
			var ix, iz,
			width_half = width / 2,
			height_half = height / 2,
			gridX = segmentsWidth || 1,
			gridZ = segmentsheight || 1,
			gridX1 = gridX + 1,
			gridZ1 = gridZ + 1,
			segment_width = width / gridX,
			segment_height = height / gridZ,
			normal = new THREE.Vector3( 0, 0, 1 );
			
			
			   var   i = 1024,
				  vertices = new Array(i),
				  x, y

			  while(i) {
				  x = (Math.random() - 0.5)*512
				  y = (Math.random() - 0.5)*512
				  z = (Math.random() - 0.5)*512

				vertices[--i] = {x: x, y: y, z:z}
			  }
			  
			   console.time("triangulate")
			  var triangles = triangulate(vertices)
			  console.timeEnd("triangulate")

			  i = triangles.length
			  //TODO
			  /*
			  while(i)
				triangles[--i].draw(ctx)
				*/
		
			

			for ( iz = 0; iz < gridZ1; iz ++ ) {

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var x = ix * segment_width - width_half;
					var y = iz * segment_height - height_half;

					geometry.vertices.push( new THREE.Vector3( x, - y, Math.random()*x ) );

				}

			}

			for ( iz = 0; iz < gridZ; iz ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = ix + gridX1 * iz;
					var b = ix + gridX1 * ( iz + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iz + 1 );
					var d = ( ix + 1 ) + gridX1 * iz;

					var face = new THREE.Face3( a, b, c );

					geometry.faces.push( face );
					geometry.faceVertexUvs[ 0 ].push( [
						new THREE.UV( 0,0 ),
						new THREE.UV( 0, 1 ),
						new THREE.UV( 1, 0 )
					] );

				}

			}
				
		
///////////////------------------------------------------		
		
		
		
		
		//var geometry = new THREE.PlaneGeometry(canvas2.width, canvas2.height,16,16);


		var mesh2 = new THREE.Mesh(
			geometry,
			material2
		  );
		mesh2.position.set(0,-10,0);
		mesh2.rotation.x = - Math.PI / 2;
		scene.add( mesh2 );
		
		var axes = new THREE.AxisHelper();
		axes.scale.set( 1, 1, 1 );
		scene.add( axes );

	

}

function drawToCanvas(src, posX, posY){
	// load an image
		var imageObj = new Image();
		imageObj.crossOrigin = "anonymous";
		imageObj.src = src;
		// after the image is loaded, this function executes
		imageObj.onload = function()
		{  
			context2.drawImage(imageObj, posX, posY);
			if ( texture2 ) // checks if texture exists
				texture2.needsUpdate = true;
		};  

}

function animate() 
{
    requestAnimationFrame( animate );
	render();		
	update();
}

function update()
{
	if ( keyboard.pressed("z") ) 
	{ 
		// do something
	}
	
	controls.update();
	stats.update();
}

function render() 
{
	renderer.render( scene, camera );
}



function initialize() {

	var mapOptions = {
		center: new google.maps.LatLng(48.86144,2.333981),
		zoom: 13,
		mapTypeId: google.maps.MapTypeId.ROADMAP
	};
	map = new google.maps.Map(document.getElementById("map_canvas"),
	mapOptions);
	
	google.maps.event.addListener(map, 'idle', function() {
		var bounds = map.getBounds();
		var sw = bounds.getSouthWest();
		var ne = bounds.getNorthEast();
		var center = map.getCenter();
		var zoom = map.getZoom();
		$("#coords").text("lat: "+sw.lat()+" to "+ne.lat());
		//$("#tt_canvas").attr("src","http://maps.googleapis.com/maps/api/staticmap?center="+center+"&zoom="+zoom+"&size=512x512&sensor=false&scale=2");
		
		
		var scale = Math.pow(2,zoom);
		var centerPt = proj.fromLatLngToPoint(center);
		
		var lowX = Math.floor(centerPt.x * scale -(512/2));
		var highX = Math.floor(centerPt.x * scale +(512/2));
		var lowY = Math.floor(centerPt.y * scale -(512/2));
		var highY = Math.floor(centerPt.y * scale +(512/2));
		
		var lowTileX = Math.floor(lowX / TILE_SIZE);
		var highTileX = Math.floor(highX / TILE_SIZE) +1;
		var lowTileY = Math.floor(lowY / TILE_SIZE);
		var highTileY = Math.floor(highY / TILE_SIZE) +1;
		

		console.log("lowX"+lowX);
		console.log("highX"+highX);
		console.log("lowTileX"+lowTileX);
		console.log("highTileX"+highTileX);
		
		for ( tileX = lowTileX; tileX < highTileX ; tileX ++){
			for ( tileY = lowTileY; tileY < highTileY ; tileY ++){
				(function(){
					var cornerX = tileX * TILE_SIZE;
					var cornerY = tileY * TILE_SIZE;
					var img = document.createElement('img');
					img.src = "http://mt1.googleapis.com/vt"
						+ "?x=" + tileX
						+ "&y=" + tileY
						+ "&z=" + zoom;
					drawToCanvas(img.src, cornerX-lowX,cornerY-lowY);
				})();
			}
		}
	});
	
	google.maps.event.addListener(map, 'mousedown', function(event) {
		console.log(event);
	});
	
}




    </script>
  </body>
</html>